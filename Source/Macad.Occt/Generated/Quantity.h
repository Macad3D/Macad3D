// Generated wrapper code for package Quantity

#pragma once

#include "Standard.h"

namespace Macad
{
namespace Occt
{
//---------------------------------------------------------------------
//  Enum  Quantity_NameOfColor
//---------------------------------------------------------------------
/// <summary>
/// Definition of names of known colors.
/// The names come (mostly) from the X11 specification.
/// </summary>
public enum class Quantity_NameOfColor
{
	Quantity_NOC_BLACK = 0,
	Quantity_NOC_MATRABLUE = 1,
	Quantity_NOC_MATRAGRAY = 2,
	Quantity_NOC_ALICEBLUE = 3,
	Quantity_NOC_ANTIQUEWHITE = 4,
	Quantity_NOC_ANTIQUEWHITE1 = 5,
	Quantity_NOC_ANTIQUEWHITE2 = 6,
	Quantity_NOC_ANTIQUEWHITE3 = 7,
	Quantity_NOC_ANTIQUEWHITE4 = 8,
	Quantity_NOC_AQUAMARINE1 = 9,
	Quantity_NOC_AQUAMARINE2 = 10,
	Quantity_NOC_AQUAMARINE4 = 11,
	Quantity_NOC_AZURE = 12,
	Quantity_NOC_AZURE2 = 13,
	Quantity_NOC_AZURE3 = 14,
	Quantity_NOC_AZURE4 = 15,
	Quantity_NOC_BEIGE = 16,
	Quantity_NOC_BISQUE = 17,
	Quantity_NOC_BISQUE2 = 18,
	Quantity_NOC_BISQUE3 = 19,
	Quantity_NOC_BISQUE4 = 20,
	Quantity_NOC_BLANCHEDALMOND = 21,
	Quantity_NOC_BLUE = 22,
	Quantity_NOC_BLUE1 = 22,
	Quantity_NOC_BLUE2 = 23,
	Quantity_NOC_BLUE3 = 24,
	Quantity_NOC_BLUE4 = 25,
	Quantity_NOC_BLUEVIOLET = 26,
	Quantity_NOC_BROWN = 27,
	Quantity_NOC_BROWN1 = 28,
	Quantity_NOC_BROWN2 = 29,
	Quantity_NOC_BROWN3 = 30,
	Quantity_NOC_BROWN4 = 31,
	Quantity_NOC_BURLYWOOD = 32,
	Quantity_NOC_BURLYWOOD1 = 33,
	Quantity_NOC_BURLYWOOD2 = 34,
	Quantity_NOC_BURLYWOOD3 = 35,
	Quantity_NOC_BURLYWOOD4 = 36,
	Quantity_NOC_CADETBLUE = 37,
	Quantity_NOC_CADETBLUE1 = 38,
	Quantity_NOC_CADETBLUE2 = 39,
	Quantity_NOC_CADETBLUE3 = 40,
	Quantity_NOC_CADETBLUE4 = 41,
	Quantity_NOC_CHARTREUSE = 42,
	Quantity_NOC_CHARTREUSE1 = 42,
	Quantity_NOC_CHARTREUSE2 = 43,
	Quantity_NOC_CHARTREUSE3 = 44,
	Quantity_NOC_CHARTREUSE4 = 45,
	Quantity_NOC_CHOCOLATE = 46,
	Quantity_NOC_CHOCOLATE1 = 47,
	Quantity_NOC_CHOCOLATE2 = 48,
	Quantity_NOC_CHOCOLATE3 = 49,
	Quantity_NOC_CHOCOLATE4 = 50,
	Quantity_NOC_CORAL = 51,
	Quantity_NOC_CORAL1 = 52,
	Quantity_NOC_CORAL2 = 53,
	Quantity_NOC_CORAL3 = 54,
	Quantity_NOC_CORAL4 = 55,
	Quantity_NOC_CORNFLOWERBLUE = 56,
	Quantity_NOC_CORNSILK1 = 57,
	Quantity_NOC_CORNSILK2 = 58,
	Quantity_NOC_CORNSILK3 = 59,
	Quantity_NOC_CORNSILK4 = 60,
	Quantity_NOC_CYAN = 61,
	Quantity_NOC_CYAN1 = 61,
	Quantity_NOC_CYAN2 = 62,
	Quantity_NOC_CYAN3 = 63,
	Quantity_NOC_CYAN4 = 64,
	Quantity_NOC_DARKGOLDENROD = 65,
	Quantity_NOC_DARKGOLDENROD1 = 66,
	Quantity_NOC_DARKGOLDENROD2 = 67,
	Quantity_NOC_DARKGOLDENROD3 = 68,
	Quantity_NOC_DARKGOLDENROD4 = 69,
	Quantity_NOC_DARKGREEN = 70,
	Quantity_NOC_DARKKHAKI = 71,
	Quantity_NOC_DARKOLIVEGREEN = 72,
	Quantity_NOC_DARKOLIVEGREEN1 = 73,
	Quantity_NOC_DARKOLIVEGREEN2 = 74,
	Quantity_NOC_DARKOLIVEGREEN3 = 75,
	Quantity_NOC_DARKOLIVEGREEN4 = 76,
	Quantity_NOC_DARKORANGE = 77,
	Quantity_NOC_DARKORANGE1 = 78,
	Quantity_NOC_DARKORANGE2 = 79,
	Quantity_NOC_DARKORANGE3 = 80,
	Quantity_NOC_DARKORANGE4 = 81,
	Quantity_NOC_DARKORCHID = 82,
	Quantity_NOC_DARKORCHID1 = 83,
	Quantity_NOC_DARKORCHID2 = 84,
	Quantity_NOC_DARKORCHID3 = 85,
	Quantity_NOC_DARKORCHID4 = 86,
	Quantity_NOC_DARKSALMON = 87,
	Quantity_NOC_DARKSEAGREEN = 88,
	Quantity_NOC_DARKSEAGREEN1 = 89,
	Quantity_NOC_DARKSEAGREEN2 = 90,
	Quantity_NOC_DARKSEAGREEN3 = 91,
	Quantity_NOC_DARKSEAGREEN4 = 92,
	Quantity_NOC_DARKSLATEBLUE = 93,
	Quantity_NOC_DARKSLATEGRAY1 = 94,
	Quantity_NOC_DARKSLATEGRAY2 = 95,
	Quantity_NOC_DARKSLATEGRAY3 = 96,
	Quantity_NOC_DARKSLATEGRAY4 = 97,
	Quantity_NOC_DARKSLATEGRAY = 98,
	Quantity_NOC_DARKTURQUOISE = 99,
	Quantity_NOC_DARKVIOLET = 100,
	Quantity_NOC_DEEPPINK = 101,
	Quantity_NOC_DEEPPINK2 = 102,
	Quantity_NOC_DEEPPINK3 = 103,
	Quantity_NOC_DEEPPINK4 = 104,
	Quantity_NOC_DEEPSKYBLUE1 = 105,
	Quantity_NOC_DEEPSKYBLUE2 = 106,
	Quantity_NOC_DEEPSKYBLUE3 = 107,
	Quantity_NOC_DEEPSKYBLUE4 = 108,
	Quantity_NOC_DODGERBLUE1 = 109,
	Quantity_NOC_DODGERBLUE2 = 110,
	Quantity_NOC_DODGERBLUE3 = 111,
	Quantity_NOC_DODGERBLUE4 = 112,
	Quantity_NOC_FIREBRICK = 113,
	Quantity_NOC_FIREBRICK1 = 114,
	Quantity_NOC_FIREBRICK2 = 115,
	Quantity_NOC_FIREBRICK3 = 116,
	Quantity_NOC_FIREBRICK4 = 117,
	Quantity_NOC_FLORALWHITE = 118,
	Quantity_NOC_FORESTGREEN = 119,
	Quantity_NOC_GAINSBORO = 120,
	Quantity_NOC_GHOSTWHITE = 121,
	Quantity_NOC_GOLD = 122,
	Quantity_NOC_GOLD1 = 122,
	Quantity_NOC_GOLD2 = 123,
	Quantity_NOC_GOLD3 = 124,
	Quantity_NOC_GOLD4 = 125,
	Quantity_NOC_GOLDENROD = 126,
	Quantity_NOC_GOLDENROD1 = 127,
	Quantity_NOC_GOLDENROD2 = 128,
	Quantity_NOC_GOLDENROD3 = 129,
	Quantity_NOC_GOLDENROD4 = 130,
	Quantity_NOC_GRAY = 131,
	Quantity_NOC_GRAY0 = 132,
	Quantity_NOC_GRAY1 = 133,
	Quantity_NOC_GRAY2 = 134,
	Quantity_NOC_GRAY3 = 135,
	Quantity_NOC_GRAY4 = 136,
	Quantity_NOC_GRAY5 = 137,
	Quantity_NOC_GRAY6 = 138,
	Quantity_NOC_GRAY7 = 139,
	Quantity_NOC_GRAY8 = 140,
	Quantity_NOC_GRAY9 = 141,
	Quantity_NOC_GRAY10 = 142,
	Quantity_NOC_GRAY11 = 143,
	Quantity_NOC_GRAY12 = 144,
	Quantity_NOC_GRAY13 = 145,
	Quantity_NOC_GRAY14 = 146,
	Quantity_NOC_GRAY15 = 147,
	Quantity_NOC_GRAY16 = 148,
	Quantity_NOC_GRAY17 = 149,
	Quantity_NOC_GRAY18 = 150,
	Quantity_NOC_GRAY19 = 151,
	Quantity_NOC_GRAY20 = 152,
	Quantity_NOC_GRAY21 = 153,
	Quantity_NOC_GRAY22 = 154,
	Quantity_NOC_GRAY23 = 155,
	Quantity_NOC_GRAY24 = 156,
	Quantity_NOC_GRAY25 = 157,
	Quantity_NOC_GRAY26 = 158,
	Quantity_NOC_GRAY27 = 159,
	Quantity_NOC_GRAY28 = 160,
	Quantity_NOC_GRAY29 = 161,
	Quantity_NOC_GRAY30 = 162,
	Quantity_NOC_GRAY31 = 163,
	Quantity_NOC_GRAY32 = 164,
	Quantity_NOC_GRAY33 = 165,
	Quantity_NOC_GRAY34 = 166,
	Quantity_NOC_GRAY35 = 167,
	Quantity_NOC_GRAY36 = 168,
	Quantity_NOC_GRAY37 = 169,
	Quantity_NOC_GRAY38 = 170,
	Quantity_NOC_GRAY39 = 171,
	Quantity_NOC_GRAY40 = 172,
	Quantity_NOC_GRAY41 = 173,
	Quantity_NOC_GRAY42 = 174,
	Quantity_NOC_GRAY43 = 175,
	Quantity_NOC_GRAY44 = 176,
	Quantity_NOC_GRAY45 = 177,
	Quantity_NOC_GRAY46 = 178,
	Quantity_NOC_GRAY47 = 179,
	Quantity_NOC_GRAY48 = 180,
	Quantity_NOC_GRAY49 = 181,
	Quantity_NOC_GRAY50 = 182,
	Quantity_NOC_GRAY51 = 183,
	Quantity_NOC_GRAY52 = 184,
	Quantity_NOC_GRAY53 = 185,
	Quantity_NOC_GRAY54 = 186,
	Quantity_NOC_GRAY55 = 187,
	Quantity_NOC_GRAY56 = 188,
	Quantity_NOC_GRAY57 = 189,
	Quantity_NOC_GRAY58 = 190,
	Quantity_NOC_GRAY59 = 191,
	Quantity_NOC_GRAY60 = 192,
	Quantity_NOC_GRAY61 = 193,
	Quantity_NOC_GRAY62 = 194,
	Quantity_NOC_GRAY63 = 195,
	Quantity_NOC_GRAY64 = 196,
	Quantity_NOC_GRAY65 = 197,
	Quantity_NOC_GRAY66 = 198,
	Quantity_NOC_GRAY67 = 199,
	Quantity_NOC_GRAY68 = 200,
	Quantity_NOC_GRAY69 = 201,
	Quantity_NOC_GRAY70 = 202,
	Quantity_NOC_GRAY71 = 203,
	Quantity_NOC_GRAY72 = 204,
	Quantity_NOC_GRAY73 = 205,
	Quantity_NOC_GRAY74 = 206,
	Quantity_NOC_GRAY75 = 207,
	Quantity_NOC_GRAY76 = 208,
	Quantity_NOC_GRAY77 = 209,
	Quantity_NOC_GRAY78 = 210,
	Quantity_NOC_GRAY79 = 211,
	Quantity_NOC_GRAY80 = 212,
	Quantity_NOC_GRAY81 = 213,
	Quantity_NOC_GRAY82 = 214,
	Quantity_NOC_GRAY83 = 215,
	Quantity_NOC_GRAY85 = 216,
	Quantity_NOC_GRAY86 = 217,
	Quantity_NOC_GRAY87 = 218,
	Quantity_NOC_GRAY88 = 219,
	Quantity_NOC_GRAY89 = 220,
	Quantity_NOC_GRAY90 = 221,
	Quantity_NOC_GRAY91 = 222,
	Quantity_NOC_GRAY92 = 223,
	Quantity_NOC_GRAY93 = 224,
	Quantity_NOC_GRAY94 = 225,
	Quantity_NOC_GRAY95 = 226,
	Quantity_NOC_GRAY97 = 227,
	Quantity_NOC_GRAY98 = 228,
	Quantity_NOC_GRAY99 = 229,
	Quantity_NOC_GREEN = 230,
	Quantity_NOC_GREEN1 = 230,
	Quantity_NOC_GREEN2 = 231,
	Quantity_NOC_GREEN3 = 232,
	Quantity_NOC_GREEN4 = 233,
	Quantity_NOC_GREENYELLOW = 234,
	Quantity_NOC_HONEYDEW = 235,
	Quantity_NOC_HONEYDEW2 = 236,
	Quantity_NOC_HONEYDEW3 = 237,
	Quantity_NOC_HONEYDEW4 = 238,
	Quantity_NOC_HOTPINK = 239,
	Quantity_NOC_HOTPINK1 = 240,
	Quantity_NOC_HOTPINK2 = 241,
	Quantity_NOC_HOTPINK3 = 242,
	Quantity_NOC_HOTPINK4 = 243,
	Quantity_NOC_INDIANRED = 244,
	Quantity_NOC_INDIANRED1 = 245,
	Quantity_NOC_INDIANRED2 = 246,
	Quantity_NOC_INDIANRED3 = 247,
	Quantity_NOC_INDIANRED4 = 248,
	Quantity_NOC_IVORY = 249,
	Quantity_NOC_IVORY2 = 250,
	Quantity_NOC_IVORY3 = 251,
	Quantity_NOC_IVORY4 = 252,
	Quantity_NOC_KHAKI = 253,
	Quantity_NOC_KHAKI1 = 254,
	Quantity_NOC_KHAKI2 = 255,
	Quantity_NOC_KHAKI3 = 256,
	Quantity_NOC_KHAKI4 = 257,
	Quantity_NOC_LAVENDER = 258,
	Quantity_NOC_LAVENDERBLUSH1 = 259,
	Quantity_NOC_LAVENDERBLUSH2 = 260,
	Quantity_NOC_LAVENDERBLUSH3 = 261,
	Quantity_NOC_LAVENDERBLUSH4 = 262,
	Quantity_NOC_LAWNGREEN = 263,
	Quantity_NOC_LEMONCHIFFON1 = 264,
	Quantity_NOC_LEMONCHIFFON2 = 265,
	Quantity_NOC_LEMONCHIFFON3 = 266,
	Quantity_NOC_LEMONCHIFFON4 = 267,
	Quantity_NOC_LIGHTBLUE = 268,
	Quantity_NOC_LIGHTBLUE1 = 269,
	Quantity_NOC_LIGHTBLUE2 = 270,
	Quantity_NOC_LIGHTBLUE3 = 271,
	Quantity_NOC_LIGHTBLUE4 = 272,
	Quantity_NOC_LIGHTCORAL = 273,
	Quantity_NOC_LIGHTCYAN = 274,
	Quantity_NOC_LIGHTCYAN1 = 274,
	Quantity_NOC_LIGHTCYAN2 = 275,
	Quantity_NOC_LIGHTCYAN3 = 276,
	Quantity_NOC_LIGHTCYAN4 = 277,
	Quantity_NOC_LIGHTGOLDENROD = 278,
	Quantity_NOC_LIGHTGOLDENROD1 = 279,
	Quantity_NOC_LIGHTGOLDENROD2 = 280,
	Quantity_NOC_LIGHTGOLDENROD3 = 281,
	Quantity_NOC_LIGHTGOLDENROD4 = 282,
	Quantity_NOC_LIGHTGOLDENRODYELLOW = 283,
	Quantity_NOC_LIGHTGRAY = 284,
	Quantity_NOC_LIGHTPINK = 285,
	Quantity_NOC_LIGHTPINK1 = 286,
	Quantity_NOC_LIGHTPINK2 = 287,
	Quantity_NOC_LIGHTPINK3 = 288,
	Quantity_NOC_LIGHTPINK4 = 289,
	Quantity_NOC_LIGHTSALMON1 = 290,
	Quantity_NOC_LIGHTSALMON2 = 291,
	Quantity_NOC_LIGHTSALMON3 = 292,
	Quantity_NOC_LIGHTSALMON4 = 293,
	Quantity_NOC_LIGHTSEAGREEN = 294,
	Quantity_NOC_LIGHTSKYBLUE = 295,
	Quantity_NOC_LIGHTSKYBLUE1 = 296,
	Quantity_NOC_LIGHTSKYBLUE2 = 297,
	Quantity_NOC_LIGHTSKYBLUE3 = 298,
	Quantity_NOC_LIGHTSKYBLUE4 = 299,
	Quantity_NOC_LIGHTSLATEBLUE = 300,
	Quantity_NOC_LIGHTSLATEGRAY = 301,
	Quantity_NOC_LIGHTSTEELBLUE = 302,
	Quantity_NOC_LIGHTSTEELBLUE1 = 303,
	Quantity_NOC_LIGHTSTEELBLUE2 = 304,
	Quantity_NOC_LIGHTSTEELBLUE3 = 305,
	Quantity_NOC_LIGHTSTEELBLUE4 = 306,
	Quantity_NOC_LIGHTYELLOW = 307,
	Quantity_NOC_LIGHTYELLOW2 = 308,
	Quantity_NOC_LIGHTYELLOW3 = 309,
	Quantity_NOC_LIGHTYELLOW4 = 310,
	Quantity_NOC_LIMEGREEN = 311,
	Quantity_NOC_LINEN = 312,
	Quantity_NOC_MAGENTA = 313,
	Quantity_NOC_MAGENTA1 = 313,
	Quantity_NOC_MAGENTA2 = 314,
	Quantity_NOC_MAGENTA3 = 315,
	Quantity_NOC_MAGENTA4 = 316,
	Quantity_NOC_MAROON = 317,
	Quantity_NOC_MAROON1 = 318,
	Quantity_NOC_MAROON2 = 319,
	Quantity_NOC_MAROON3 = 320,
	Quantity_NOC_MAROON4 = 321,
	Quantity_NOC_MEDIUMAQUAMARINE = 322,
	Quantity_NOC_MEDIUMORCHID = 323,
	Quantity_NOC_MEDIUMORCHID1 = 324,
	Quantity_NOC_MEDIUMORCHID2 = 325,
	Quantity_NOC_MEDIUMORCHID3 = 326,
	Quantity_NOC_MEDIUMORCHID4 = 327,
	Quantity_NOC_MEDIUMPURPLE = 328,
	Quantity_NOC_MEDIUMPURPLE1 = 329,
	Quantity_NOC_MEDIUMPURPLE2 = 330,
	Quantity_NOC_MEDIUMPURPLE3 = 331,
	Quantity_NOC_MEDIUMPURPLE4 = 332,
	Quantity_NOC_MEDIUMSEAGREEN = 333,
	Quantity_NOC_MEDIUMSLATEBLUE = 334,
	Quantity_NOC_MEDIUMSPRINGGREEN = 335,
	Quantity_NOC_MEDIUMTURQUOISE = 336,
	Quantity_NOC_MEDIUMVIOLETRED = 337,
	Quantity_NOC_MIDNIGHTBLUE = 338,
	Quantity_NOC_MINTCREAM = 339,
	Quantity_NOC_MISTYROSE = 340,
	Quantity_NOC_MISTYROSE2 = 341,
	Quantity_NOC_MISTYROSE3 = 342,
	Quantity_NOC_MISTYROSE4 = 343,
	Quantity_NOC_MOCCASIN = 344,
	Quantity_NOC_NAVAJOWHITE1 = 345,
	Quantity_NOC_NAVAJOWHITE2 = 346,
	Quantity_NOC_NAVAJOWHITE3 = 347,
	Quantity_NOC_NAVAJOWHITE4 = 348,
	Quantity_NOC_NAVYBLUE = 349,
	Quantity_NOC_OLDLACE = 350,
	Quantity_NOC_OLIVEDRAB = 351,
	Quantity_NOC_OLIVEDRAB1 = 352,
	Quantity_NOC_OLIVEDRAB2 = 353,
	Quantity_NOC_OLIVEDRAB3 = 354,
	Quantity_NOC_OLIVEDRAB4 = 355,
	Quantity_NOC_ORANGE = 356,
	Quantity_NOC_ORANGE1 = 356,
	Quantity_NOC_ORANGE2 = 357,
	Quantity_NOC_ORANGE3 = 358,
	Quantity_NOC_ORANGE4 = 359,
	Quantity_NOC_ORANGERED = 360,
	Quantity_NOC_ORANGERED1 = 360,
	Quantity_NOC_ORANGERED2 = 361,
	Quantity_NOC_ORANGERED3 = 362,
	Quantity_NOC_ORANGERED4 = 363,
	Quantity_NOC_ORCHID = 364,
	Quantity_NOC_ORCHID1 = 365,
	Quantity_NOC_ORCHID2 = 366,
	Quantity_NOC_ORCHID3 = 367,
	Quantity_NOC_ORCHID4 = 368,
	Quantity_NOC_PALEGOLDENROD = 369,
	Quantity_NOC_PALEGREEN = 370,
	Quantity_NOC_PALEGREEN1 = 371,
	Quantity_NOC_PALEGREEN2 = 372,
	Quantity_NOC_PALEGREEN3 = 373,
	Quantity_NOC_PALEGREEN4 = 374,
	Quantity_NOC_PALETURQUOISE = 375,
	Quantity_NOC_PALETURQUOISE1 = 376,
	Quantity_NOC_PALETURQUOISE2 = 377,
	Quantity_NOC_PALETURQUOISE3 = 378,
	Quantity_NOC_PALETURQUOISE4 = 379,
	Quantity_NOC_PALEVIOLETRED = 380,
	Quantity_NOC_PALEVIOLETRED1 = 381,
	Quantity_NOC_PALEVIOLETRED2 = 382,
	Quantity_NOC_PALEVIOLETRED3 = 383,
	Quantity_NOC_PALEVIOLETRED4 = 384,
	Quantity_NOC_PAPAYAWHIP = 385,
	Quantity_NOC_PEACHPUFF = 386,
	Quantity_NOC_PEACHPUFF2 = 387,
	Quantity_NOC_PEACHPUFF3 = 388,
	Quantity_NOC_PEACHPUFF4 = 389,
	Quantity_NOC_PERU = 390,
	Quantity_NOC_PINK = 391,
	Quantity_NOC_PINK1 = 392,
	Quantity_NOC_PINK2 = 393,
	Quantity_NOC_PINK3 = 394,
	Quantity_NOC_PINK4 = 395,
	Quantity_NOC_PLUM = 396,
	Quantity_NOC_PLUM1 = 397,
	Quantity_NOC_PLUM2 = 398,
	Quantity_NOC_PLUM3 = 399,
	Quantity_NOC_PLUM4 = 400,
	Quantity_NOC_POWDERBLUE = 401,
	Quantity_NOC_PURPLE = 402,
	Quantity_NOC_PURPLE1 = 403,
	Quantity_NOC_PURPLE2 = 404,
	Quantity_NOC_PURPLE3 = 405,
	Quantity_NOC_PURPLE4 = 406,
	Quantity_NOC_RED = 407,
	Quantity_NOC_RED1 = 407,
	Quantity_NOC_RED2 = 408,
	Quantity_NOC_RED3 = 409,
	Quantity_NOC_RED4 = 410,
	Quantity_NOC_ROSYBROWN = 411,
	Quantity_NOC_ROSYBROWN1 = 412,
	Quantity_NOC_ROSYBROWN2 = 413,
	Quantity_NOC_ROSYBROWN3 = 414,
	Quantity_NOC_ROSYBROWN4 = 415,
	Quantity_NOC_ROYALBLUE = 416,
	Quantity_NOC_ROYALBLUE1 = 417,
	Quantity_NOC_ROYALBLUE2 = 418,
	Quantity_NOC_ROYALBLUE3 = 419,
	Quantity_NOC_ROYALBLUE4 = 420,
	Quantity_NOC_SADDLEBROWN = 421,
	Quantity_NOC_SALMON = 422,
	Quantity_NOC_SALMON1 = 423,
	Quantity_NOC_SALMON2 = 424,
	Quantity_NOC_SALMON3 = 425,
	Quantity_NOC_SALMON4 = 426,
	Quantity_NOC_SANDYBROWN = 427,
	Quantity_NOC_SEAGREEN = 428,
	Quantity_NOC_SEAGREEN1 = 429,
	Quantity_NOC_SEAGREEN2 = 430,
	Quantity_NOC_SEAGREEN3 = 431,
	Quantity_NOC_SEAGREEN4 = 432,
	Quantity_NOC_SEASHELL = 433,
	Quantity_NOC_SEASHELL2 = 434,
	Quantity_NOC_SEASHELL3 = 435,
	Quantity_NOC_SEASHELL4 = 436,
	Quantity_NOC_BEET = 437,
	Quantity_NOC_TEAL = 438,
	Quantity_NOC_SIENNA = 439,
	Quantity_NOC_SIENNA1 = 440,
	Quantity_NOC_SIENNA2 = 441,
	Quantity_NOC_SIENNA3 = 442,
	Quantity_NOC_SIENNA4 = 443,
	Quantity_NOC_SKYBLUE = 444,
	Quantity_NOC_SKYBLUE1 = 445,
	Quantity_NOC_SKYBLUE2 = 446,
	Quantity_NOC_SKYBLUE3 = 447,
	Quantity_NOC_SKYBLUE4 = 448,
	Quantity_NOC_SLATEBLUE = 449,
	Quantity_NOC_SLATEBLUE1 = 450,
	Quantity_NOC_SLATEBLUE2 = 451,
	Quantity_NOC_SLATEBLUE3 = 452,
	Quantity_NOC_SLATEBLUE4 = 453,
	Quantity_NOC_SLATEGRAY1 = 454,
	Quantity_NOC_SLATEGRAY2 = 455,
	Quantity_NOC_SLATEGRAY3 = 456,
	Quantity_NOC_SLATEGRAY4 = 457,
	Quantity_NOC_SLATEGRAY = 458,
	Quantity_NOC_SNOW = 459,
	Quantity_NOC_SNOW2 = 460,
	Quantity_NOC_SNOW3 = 461,
	Quantity_NOC_SNOW4 = 462,
	Quantity_NOC_SPRINGGREEN = 463,
	Quantity_NOC_SPRINGGREEN2 = 464,
	Quantity_NOC_SPRINGGREEN3 = 465,
	Quantity_NOC_SPRINGGREEN4 = 466,
	Quantity_NOC_STEELBLUE = 467,
	Quantity_NOC_STEELBLUE1 = 468,
	Quantity_NOC_STEELBLUE2 = 469,
	Quantity_NOC_STEELBLUE3 = 470,
	Quantity_NOC_STEELBLUE4 = 471,
	Quantity_NOC_TAN = 472,
	Quantity_NOC_TAN1 = 473,
	Quantity_NOC_TAN2 = 474,
	Quantity_NOC_TAN3 = 475,
	Quantity_NOC_TAN4 = 476,
	Quantity_NOC_THISTLE = 477,
	Quantity_NOC_THISTLE1 = 478,
	Quantity_NOC_THISTLE2 = 479,
	Quantity_NOC_THISTLE3 = 480,
	Quantity_NOC_THISTLE4 = 481,
	Quantity_NOC_TOMATO = 482,
	Quantity_NOC_TOMATO1 = 482,
	Quantity_NOC_TOMATO2 = 483,
	Quantity_NOC_TOMATO3 = 484,
	Quantity_NOC_TOMATO4 = 485,
	Quantity_NOC_TURQUOISE = 486,
	Quantity_NOC_TURQUOISE1 = 487,
	Quantity_NOC_TURQUOISE2 = 488,
	Quantity_NOC_TURQUOISE3 = 489,
	Quantity_NOC_TURQUOISE4 = 490,
	Quantity_NOC_VIOLET = 491,
	Quantity_NOC_VIOLETRED = 492,
	Quantity_NOC_VIOLETRED1 = 493,
	Quantity_NOC_VIOLETRED2 = 494,
	Quantity_NOC_VIOLETRED3 = 495,
	Quantity_NOC_VIOLETRED4 = 496,
	Quantity_NOC_WHEAT = 497,
	Quantity_NOC_WHEAT1 = 498,
	Quantity_NOC_WHEAT2 = 499,
	Quantity_NOC_WHEAT3 = 500,
	Quantity_NOC_WHEAT4 = 501,
	Quantity_NOC_WHITESMOKE = 502,
	Quantity_NOC_YELLOW = 503,
	Quantity_NOC_YELLOW1 = 503,
	Quantity_NOC_YELLOW2 = 504,
	Quantity_NOC_YELLOW3 = 505,
	Quantity_NOC_YELLOW4 = 506,
	Quantity_NOC_YELLOWGREEN = 507,
	Quantity_NOC_WHITE = 508
}; // enum  class Quantity_NameOfColor

//---------------------------------------------------------------------
//  Enum  Quantity_TypeOfColor
//---------------------------------------------------------------------
/// <summary>
/// Identifies color definition systems.
/// </summary>
public enum class Quantity_TypeOfColor
{
	Quantity_TOC_RGB = 0,
	Quantity_TOC_sRGB = 1,
	Quantity_TOC_HLS = 2,
	Quantity_TOC_CIELab = 3,
	Quantity_TOC_CIELch = 4
}; // enum  class Quantity_TypeOfColor

//---------------------------------------------------------------------
//  Enum  Quantity_PhysicalQuantity
//---------------------------------------------------------------------
/// <summary>
/// List of all physical quantities(Afnor)
/// </summary>
public enum class Quantity_PhysicalQuantity
{
	Quantity_MASS = 0,
	Quantity_PLANEANGLE = 1,
	Quantity_SOLIDANGLE = 2,
	Quantity_LENGTH = 3,
	Quantity_AREA = 4,
	Quantity_VOLUME = 5,
	Quantity_SPEED = 6,
	Quantity_VELOCITY = 7,
	Quantity_ACCELERATION = 8,
	Quantity_ANGULARVELOCITY = 9,
	Quantity_FREQUENCY = 10,
	Quantity_TEMPERATURE = 11,
	Quantity_AMOUNTOFSUBSTANCE = 12,
	Quantity_DENSITY = 13,
	Quantity_MASSFLOW = 14,
	Quantity_VOLUMEFLOW = 15,
	Quantity_CONSUMPTION = 16,
	Quantity_MOMENTUM = 17,
	Quantity_KINETICMOMENT = 18,
	Quantity_MOMENTOFINERTIA = 19,
	Quantity_FORCE = 20,
	Quantity_MOMENTOFAFORCE = 21,
	Quantity_TORQUE = 22,
	Quantity_WEIGHT = 23,
	Quantity_PRESSURE = 24,
	Quantity_VISCOSITY = 25,
	Quantity_KINEMATICVISCOSITY = 26,
	Quantity_ENERGY = 27,
	Quantity_WORK = 28,
	Quantity_POWER = 29,
	Quantity_SURFACETENSION = 30,
	Quantity_COEFFICIENTOFEXPANSION = 31,
	Quantity_THERMALCONDUCTIVITY = 32,
	Quantity_SPECIFICHEATCAPACITY = 33,
	Quantity_ENTROPY = 34,
	Quantity_ENTHALPY = 35,
	Quantity_LUMINOUSINTENSITY = 36,
	Quantity_LUMINOUSFLUX = 37,
	Quantity_LUMINANCE = 38,
	Quantity_ILLUMINANCE = 39,
	Quantity_LUMINOUSEXPOSITION = 40,
	Quantity_LUMINOUSEFFICACITY = 41,
	Quantity_ELECTRICCHARGE = 42,
	Quantity_ELECTRICCURRENT = 43,
	Quantity_ELECTRICFIELDSTRENGTH = 44,
	Quantity_ELECTRICPOTENTIAL = 45,
	Quantity_ELECTRICCAPACITANCE = 46,
	Quantity_MAGNETICFLUX = 47,
	Quantity_MAGNETICFLUXDENSITY = 48,
	Quantity_MAGNETICFIELDSTRENGTH = 49,
	Quantity_RELUCTANCE = 50,
	Quantity_RESISTANCE = 51,
	Quantity_INDUCTANCE = 52,
	Quantity_CAPACITANCE = 53,
	Quantity_IMPEDANCE = 54,
	Quantity_ADMITTANCE = 55,
	Quantity_RESISTIVITY = 56,
	Quantity_CONDUCTIVITY = 57,
	Quantity_MOLARMASS = 58,
	Quantity_MOLARVOLUME = 59,
	Quantity_CONCENTRATION = 60,
	Quantity_MOLARCONCENTRATION = 61,
	Quantity_MOLARITY = 62,
	Quantity_SOUNDINTENSITY = 63,
	Quantity_ACOUSTICINTENSITY = 64,
	Quantity_ACTIVITY = 65,
	Quantity_ABSORBEDDOSE = 66,
	Quantity_DOSEEQUIVALENT = 67
}; // enum  class Quantity_PhysicalQuantity

//---------------------------------------------------------------------
//  Class  Quantity_Array1OfColor
//---------------------------------------------------------------------
public ref class Quantity_Array1OfColor sealed : public BaseClass<::Quantity_Array1OfColor>
{

#ifdef Include_Quantity_Array1OfColor_h
public:
	Include_Quantity_Array1OfColor_h
#endif

public:
	Quantity_Array1OfColor(::Quantity_Array1OfColor* nativeInstance)
		: BaseClass<::Quantity_Array1OfColor>( nativeInstance, true )
	{}

	Quantity_Array1OfColor(::Quantity_Array1OfColor& nativeInstance)
		: BaseClass<::Quantity_Array1OfColor>( &nativeInstance, false )
	{}

	property ::Quantity_Array1OfColor* NativeInstance
	{
		::Quantity_Array1OfColor* get()
		{
			return static_cast<::Quantity_Array1OfColor*>(_NativeInstance);
		}
	}

public:
	Quantity_Array1OfColor();
	Quantity_Array1OfColor(int theLower, int theUpper);
	Quantity_Array1OfColor(Macad::Occt::Quantity_Array1OfColor^ theOther);
	Quantity_Array1OfColor(Macad::Occt::Quantity_Color^ theBegin, int theLower, int theUpper);
	void Init(Macad::Occt::Quantity_Color^ theValue);
	int Size();
	int Length();
	bool IsEmpty();
	int Lower();
	int Upper();
	bool IsDeletable();
	bool IsAllocated();
	Macad::Occt::Quantity_Array1OfColor^ Assign(Macad::Occt::Quantity_Array1OfColor^ theOther);
	Macad::Occt::Quantity_Array1OfColor^ Move(Macad::Occt::Quantity_Array1OfColor^ theOther);
	Macad::Occt::Quantity_Color^ First();
	Macad::Occt::Quantity_Color^ ChangeFirst();
	Macad::Occt::Quantity_Color^ Last();
	Macad::Occt::Quantity_Color^ ChangeLast();
	Macad::Occt::Quantity_Color^ Value(int theIndex);
	Macad::Occt::Quantity_Color^ ChangeValue(int theIndex);
	void SetValue(int theIndex, Macad::Occt::Quantity_Color^ theItem);
	void Resize(int theLower, int theUpper, bool theToCopyData);
}; // class Quantity_Array1OfColor

//---------------------------------------------------------------------
//  Class  Quantity_Array2OfColor
//---------------------------------------------------------------------
public ref class Quantity_Array2OfColor sealed : public BaseClass<::Quantity_Array2OfColor>
{

#ifdef Include_Quantity_Array2OfColor_h
public:
	Include_Quantity_Array2OfColor_h
#endif

public:
	Quantity_Array2OfColor(::Quantity_Array2OfColor* nativeInstance)
		: BaseClass<::Quantity_Array2OfColor>( nativeInstance, true )
	{}

	Quantity_Array2OfColor(::Quantity_Array2OfColor& nativeInstance)
		: BaseClass<::Quantity_Array2OfColor>( &nativeInstance, false )
	{}

	property ::Quantity_Array2OfColor* NativeInstance
	{
		::Quantity_Array2OfColor* get()
		{
			return static_cast<::Quantity_Array2OfColor*>(_NativeInstance);
		}
	}

public:
	Quantity_Array2OfColor();
	Quantity_Array2OfColor(int theRowLower, int theRowUpper, int theColLower, int theColUpper);
	Quantity_Array2OfColor(Macad::Occt::Quantity_Array2OfColor^ theOther);
	Quantity_Array2OfColor(Macad::Occt::Quantity_Color^ theBegin, int theRowLower, int theRowUpper, int theColLower, int theColUpper);
	void Init(Macad::Occt::Quantity_Color^ theValue);
	int Size();
	int Length();
	int NbRows();
	int NbColumns();
	int RowLength();
	int ColLength();
	int LowerRow();
	int UpperRow();
	int LowerCol();
	int UpperCol();
	bool IsDeletable();
	Macad::Occt::Quantity_Array2OfColor^ Assign(Macad::Occt::Quantity_Array2OfColor^ theOther);
	Macad::Occt::Quantity_Array2OfColor^ Move(Macad::Occt::Quantity_Array2OfColor^ theOther);
	Macad::Occt::Quantity_Color^ Value(int theRow, int theCol);
	Macad::Occt::Quantity_Color^ ChangeValue(int theRow, int theCol);
	void SetValue(int theRow, int theCol, Macad::Occt::Quantity_Color^ theItem);
	void Resize(int theRowLower, int theRowUpper, int theColLower, int theColUpper, bool theToCopyData);
}; // class Quantity_Array2OfColor

//---------------------------------------------------------------------
//  Class  Quantity_ColorHasher
//---------------------------------------------------------------------
/// <summary>
/// Hasher of Quantity_Color.
/// </summary>
public ref class Quantity_ColorHasher sealed : public BaseClass<::Quantity_ColorHasher>
{

#ifdef Include_Quantity_ColorHasher_h
public:
	Include_Quantity_ColorHasher_h
#endif

public:
	Quantity_ColorHasher(::Quantity_ColorHasher* nativeInstance)
		: BaseClass<::Quantity_ColorHasher>( nativeInstance, true )
	{}

	Quantity_ColorHasher(::Quantity_ColorHasher& nativeInstance)
		: BaseClass<::Quantity_ColorHasher>( &nativeInstance, false )
	{}

	property ::Quantity_ColorHasher* NativeInstance
	{
		::Quantity_ColorHasher* get()
		{
			return static_cast<::Quantity_ColorHasher*>(_NativeInstance);
		}
	}

public:
	Quantity_ColorHasher();
	Quantity_ColorHasher(Macad::Occt::Quantity_ColorHasher^ parameter1);
	/// <summary>
	/// Returns hash code for the given RGB color, in the range [1, theUpperBound]
	/// </summary>
	/// <param name="theColor">
	/// the RGB color object which hash code is to be computed
	/// </param>
	/// <param name="theUpperBound">
	/// the upper bound of the range a computing range must be within
	/// </param>
	/// <returns>
	/// a computed hash code, in the range [1, theUpperBound]
	/// </returns>
	static int HashCode(Macad::Occt::Quantity_Color^ theColor, int theUpperBound);
	/// <summary>
	/// Returns true if two colors are equal.
	/// </summary>
	static bool IsEqual(Macad::Occt::Quantity_Color^ theColor1, Macad::Occt::Quantity_Color^ theColor2);
}; // class Quantity_ColorHasher

//---------------------------------------------------------------------
//  Class  Quantity_ColorRGBAHasher
//---------------------------------------------------------------------
/// <summary>
/// Hasher of Quantity_ColorRGBA.
/// </summary>
public ref class Quantity_ColorRGBAHasher sealed : public BaseClass<::Quantity_ColorRGBAHasher>
{

#ifdef Include_Quantity_ColorRGBAHasher_h
public:
	Include_Quantity_ColorRGBAHasher_h
#endif

public:
	Quantity_ColorRGBAHasher(::Quantity_ColorRGBAHasher* nativeInstance)
		: BaseClass<::Quantity_ColorRGBAHasher>( nativeInstance, true )
	{}

	Quantity_ColorRGBAHasher(::Quantity_ColorRGBAHasher& nativeInstance)
		: BaseClass<::Quantity_ColorRGBAHasher>( &nativeInstance, false )
	{}

	property ::Quantity_ColorRGBAHasher* NativeInstance
	{
		::Quantity_ColorRGBAHasher* get()
		{
			return static_cast<::Quantity_ColorRGBAHasher*>(_NativeInstance);
		}
	}

public:
	Quantity_ColorRGBAHasher();
	Quantity_ColorRGBAHasher(Macad::Occt::Quantity_ColorRGBAHasher^ parameter1);
	/// <summary>
	/// Returns hash code for the given RGBA color, in the range [1, theUpperBound]
	/// </summary>
	/// <param name="theColor">
	/// the RGBA color object which hash code is to be computed
	/// </param>
	/// <param name="theUpperBound">
	/// the upper bound of the range a computing hash code must be within
	/// </param>
	/// <returns>
	/// a computed hash code, in the range [1, theUpperBound]
	/// </returns>
	static int HashCode(Macad::Occt::Quantity_ColorRGBA^ theColor, int theUpperBound);
	/// <summary>
	/// Returns true if two colors are equal.
	/// </summary>
	static bool IsEqual(Macad::Occt::Quantity_ColorRGBA^ theColor1, Macad::Occt::Quantity_ColorRGBA^ theColor2);
}; // class Quantity_ColorRGBAHasher

//---------------------------------------------------------------------
//  Class  Quantity_Color
//---------------------------------------------------------------------
/// <summary>
/// This class allows the definition of an RGB color as triplet of 3 normalized floating point values (red, green, blue).
/// 
/// Although Quantity_Color can be technically used for pass-through storage of RGB triplet in any color space,
/// other OCCT interfaces taking/returning Quantity_Color would expect them in linear space.
/// Therefore, take a look into methods converting to and from non-linear sRGB color space, if needed;
/// for instance, application usually providing color picking within 0..255 range in sRGB color space.
/// </summary>
public ref class Quantity_Color sealed : public BaseClass<::Quantity_Color>
{

#ifdef Include_Quantity_Color_h
public:
	Include_Quantity_Color_h
#endif

public:
	Quantity_Color(::Quantity_Color* nativeInstance)
		: BaseClass<::Quantity_Color>( nativeInstance, true )
	{}

	Quantity_Color(::Quantity_Color& nativeInstance)
		: BaseClass<::Quantity_Color>( &nativeInstance, false )
	{}

	property ::Quantity_Color* NativeInstance
	{
		::Quantity_Color* get()
		{
			return static_cast<::Quantity_Color*>(_NativeInstance);
		}
	}

public:
	/// <summary>
	/// Creates Quantity_NOC_YELLOW color (for historical reasons).
	/// </summary>
	Quantity_Color();
	/// <summary>
	/// Creates the color from enumeration value.
	/// </summary>
	Quantity_Color(Macad::Occt::Quantity_NameOfColor theName);
	/// <summary>
	/// Creates a color according to the definition system theType.
	/// Throws exception if values are out of range.
	/// </summary>
	Quantity_Color(double theC1, double theC2, double theC3, Macad::Occt::Quantity_TypeOfColor theType);
	/// <summary>
	/// Define color from linear RGB values.
	/// </summary>
	/* Method skipped due to unknown mapping: void Quantity_Color(NCollection_Vec3<float> theRgb, ) */
	Quantity_Color(Macad::Occt::Quantity_Color^ parameter1);
	/// <summary>
	/// Returns the name of the nearest color from the Quantity_NameOfColor enumeration.
	/// </summary>
	Macad::Occt::Quantity_NameOfColor Name();
	/// <summary>
	/// Updates the color from specified named color.
	/// </summary>
	void SetValues(Macad::Occt::Quantity_NameOfColor theName);
	/// <summary>
	/// Return the color as vector of 3 float elements.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Rgb() */
	/// <summary>
	/// Returns in theC1, theC2 and theC3 the components of this color
	/// according to the color system definition theType.
	/// </summary>
	void Values(double% theC1, double% theC2, double% theC3, Macad::Occt::Quantity_TypeOfColor theType);
	/// <summary>
	/// Updates a color according to the mode specified by theType.
	/// Throws exception if values are out of range.
	/// </summary>
	void SetValues(double theC1, double theC2, double theC3, Macad::Occt::Quantity_TypeOfColor theType);
	/// <summary>
	/// Returns the Red component (quantity of red) of the color within range [0.0; 1.0].
	/// </summary>
	double Red();
	/// <summary>
	/// Returns the Green component (quantity of green) of the color within range [0.0; 1.0].
	/// </summary>
	double Green();
	/// <summary>
	/// Returns the Blue component (quantity of blue) of the color within range [0.0; 1.0].
	/// </summary>
	double Blue();
	/// <summary>
	/// Returns the Hue component (hue angle) of the color
	/// in degrees within range [0.0; 360.0], 0.0 being Red.
	/// -1.0 is a special value reserved for grayscale color (S should be 0.0)
	/// </summary>
	double Hue();
	/// <summary>
	/// Returns the Light component (value of the lightness) of the color within range [0.0; 1.0].
	/// </summary>
	double Light();
	/// <summary>
	/// Increases or decreases the intensity (variation of the lightness).
	/// The delta is a percentage. Any value greater than zero will increase the intensity.
	/// The variation is expressed as a percentage of the current value.
	/// </summary>
	void ChangeIntensity(double theDelta);
	/// <summary>
	/// Returns the Saturation component (value of the saturation) of the color within range [0.0; 1.0].
	/// </summary>
	double Saturation();
	/// <summary>
	/// Increases or decreases the contrast (variation of the saturation).
	/// The delta is a percentage. Any value greater than zero will increase the contrast.
	/// The variation is expressed as a percentage of the current value.
	/// </summary>
	void ChangeContrast(double theDelta);
	/// <summary>
	/// Returns TRUE if the distance between two colors is greater than Epsilon().
	/// </summary>
	bool IsDifferent(Macad::Occt::Quantity_Color^ theOther);
	/// <summary>
	/// Returns TRUE if the distance between two colors is no greater than Epsilon().
	/// </summary>
	bool IsEqual(Macad::Occt::Quantity_Color^ theOther);
	/// <summary>
	/// Returns the distance between two colors. It's a value between 0 and the square root of 3 (the black/white distance).
	/// </summary>
	double Distance(Macad::Occt::Quantity_Color^ theColor);
	/// <summary>
	/// Returns the square of distance between two colors.
	/// </summary>
	double SquareDistance(Macad::Occt::Quantity_Color^ theColor);
	/// <summary>
	/// Returns the percentage change of contrast and intensity between this and another color.
	/// <DC> and <DI> are percentages, either positive or negative.
	/// The calculation is with respect to this color.
	/// If <DC> is positive then <me> is more contrasty.
	/// If <DI> is positive then <me> is more intense.
	/// </summary>
	void Delta(Macad::Occt::Quantity_Color^ theColor, double% DC, double% DI);
	/// <summary>
	/// Returns the value of the perceptual difference between this color
	/// and @p theOther, computed using the CIEDE2000 formula.
	/// The difference is in range [0, 100.], with 1 approximately corresponding
	/// to the minimal percievable difference (usually difference 5 or greater is
	/// needed for the difference to be recognizable in practice).
	/// </summary>
	double DeltaE2000(Macad::Occt::Quantity_Color^ theOther);
	/// <summary>
	/// Returns the color from Quantity_NameOfColor enumeration nearest to specified RGB values.
	/// </summary>
	static Macad::Occt::Quantity_NameOfColor Name(double theR, double theG, double theB);
	/// <summary>
	/// Returns the name of the color identified by the given Quantity_NameOfColor enumeration value.
	/// </summary>
	static System::String^ StringName(Macad::Occt::Quantity_NameOfColor theColor);
	/// <summary>
	/// Finds color from predefined names.
	/// For example, the name of the color which corresponds to "BLACK" is Quantity_NOC_BLACK.
	/// Returns FALSE if name is unknown.
	/// </summary>
	static bool ColorFromName(System::String^ theName, Macad::Occt::Quantity_NameOfColor% theColor);
	/// <summary>
	/// Finds color from predefined names.
	/// </summary>
	/// <param name="theColorNameString">
	/// the color name
	/// </param>
	/// <param name="theColor">
	/// a found color
	/// </param>
	/// <returns>
	/// false if the color name is unknown, or true if the search by color name was successful
	/// </returns>
	static bool ColorFromName(System::String^ theColorNameString, Macad::Occt::Quantity_Color^ theColor);
	/// <summary>
	/// Parses the string as a hex color (like "#FF0" for short sRGB color, or "#FFFF00" for sRGB color)
	/// </summary>
	/// <param name="theHexColorString">
	/// the string to be parsed
	/// </param>
	/// <param name="theColor">
	/// a color that is a result of parsing
	/// </param>
	/// <returns>
	/// true if parsing was successful, or false otherwise
	/// </returns>
	static bool ColorFromHex(System::String^ theHexColorString, Macad::Occt::Quantity_Color^ theColor);
	/// <summary>
	/// Returns hex sRGB string in format "#FFAAFF".
	/// </summary>
	static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_Color^ theColor, bool theToPrefixHash);
	/// <summary>
	/// Returns hex sRGB string in format "#FFAAFF".
	/// </summary>
	static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_Color^ theColor);
	/// <summary>
	/// Converts sRGB components into HLS ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_sRGB_To_HLS(NCollection_Vec3<float> theRgb, ) */
	/// <summary>
	/// Converts HLS components into RGB ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_HLS_To_sRGB(NCollection_Vec3<float> theHls, ) */
	/// <summary>
	/// Converts Linear RGB components into HLS ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_LinearRGB_To_HLS(NCollection_Vec3<float> theRgb, ) */
	/// <summary>
	/// Converts HLS components into linear RGB ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_HLS_To_LinearRGB(NCollection_Vec3<float> theHls, ) */
	/// <summary>
	/// Converts linear RGB components into CIE Lab ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_LinearRGB_To_Lab(NCollection_Vec3<float> theRgb, ) */
	/// <summary>
	/// Converts CIE Lab components into CIE Lch ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_Lab_To_Lch(NCollection_Vec3<float> theLab, ) */
	/// <summary>
	/// Converts CIE Lab components into linear RGB ones.
	/// Note that the resulting values may be out of the valid range for RGB.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_Lab_To_LinearRGB(NCollection_Vec3<float> theLab, ) */
	/// <summary>
	/// Converts CIE Lch components into CIE Lab ones.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_Lch_To_Lab(NCollection_Vec3<float> theLch, ) */
	/// <summary>
	/// Convert the color value to ARGB integer value, with alpha equals to 0.
	/// So the output is formatted as 0x00RRGGBB.
	/// Note that this unpacking does NOT involve non-linear sRGB -> linear RGB conversion,
	/// as would be usually expected for RGB color packed into 4 bytes.
	/// </summary>
	/// <param name="theColor">
	/// [in] color to convert
	/// </param>
	/// <param name="theARGB">
	/// [out] result color encoded as integer
	/// </param>
	static void Color2argb(Macad::Occt::Quantity_Color^ theColor, int% theARGB);
	/// <summary>
	/// Convert integer ARGB value to Color. Alpha bits are ignored.
	/// Note that this packing does NOT involve linear -> non-linear sRGB conversion,
	/// as would be usually expected to preserve higher (for human eye) color precision in 4 bytes.
	/// </summary>
	static void Argb2color(int theARGB, Macad::Occt::Quantity_Color^ theColor);
	/// <summary>
	/// Convert linear RGB component into sRGB using OpenGL specs formula (double precision), also known as gamma correction.
	/// </summary>
	static double Convert_LinearRGB_To_sRGB(double theLinearValue);
	/// <summary>
	/// Convert linear RGB component into sRGB using OpenGL specs formula (single precision), also known as gamma correction.
	/// </summary>
	static float Convert_LinearRGB_To_sRGB(float theLinearValue);
	/// <summary>
	/// Convert sRGB component into linear RGB using OpenGL specs formula (double precision), also known as gamma correction.
	/// </summary>
	static double Convert_sRGB_To_LinearRGB(double thesRGBValue);
	/// <summary>
	/// Convert sRGB component into linear RGB using OpenGL specs formula (single precision), also known as gamma correction.
	/// </summary>
	static float Convert_sRGB_To_LinearRGB(float thesRGBValue);
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_LinearRGB_To_sRGB(NCollection_Vec3<float> theRGB, ) */
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_sRGB_To_LinearRGB(NCollection_Vec3<float> theRGB, ) */
	/// <summary>
	/// Convert linear RGB component into sRGB using approximated uniform gamma coefficient 2.2.
	/// </summary>
	static float Convert_LinearRGB_To_sRGB_approx22(float theLinearValue);
	/// <summary>
	/// Convert sRGB component into linear RGB using approximated uniform gamma coefficient 2.2
	/// </summary>
	static float Convert_sRGB_To_LinearRGB_approx22(float thesRGBValue);
	/// <summary>
	/// Convert linear RGB components into sRGB using approximated uniform gamma coefficient 2.2
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_LinearRGB_To_sRGB_approx22(NCollection_Vec3<float> theRGB, ) */
	/// <summary>
	/// Convert sRGB components into linear RGB using approximated uniform gamma coefficient 2.2
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec3<float> Convert_sRGB_To_LinearRGB_approx22(NCollection_Vec3<float> theRGB, ) */
	/// <summary>
	/// Converts HLS components into sRGB ones.
	/// </summary>
	static void HlsRgb(double theH, double theL, double theS, double% theR, double% theG, double% theB);
	/// <summary>
	/// Converts sRGB components into HLS ones.
	/// </summary>
	static void RgbHls(double theR, double theG, double theB, double% theH, double% theL, double% theS);
	/// <summary>
	/// Returns the value used to compare two colors for equality; 0.0001 by default.
	/// </summary>
	static double Epsilon();
	/// <summary>
	/// Set the value used to compare two colors for equality.
	/// </summary>
	static void SetEpsilon(double theEpsilon);
	/// <summary>
	/// Dumps the content of me into the stream
	/// </summary>
	/* Method skipped due to unknown mapping: void DumpJson(ostream theOStream, Standard_Integer theDepth, ) */
	/// <summary>
	/// Dumps the content of me into the stream
	/// </summary>
	/* Method skipped due to unknown mapping: void DumpJson(ostream theOStream, Standard_Integer theDepth, ) */
	/// <summary>
	/// Inits the content of me from the stream
	/// </summary>
	/* Method skipped due to unknown mapping: Standard_Boolean InitFromJson(stringstream theSStream, Standard_Integer theStreamPos, ) */
}; // class Quantity_Color

//---------------------------------------------------------------------
//  Class  Quantity_ColorRGBA
//---------------------------------------------------------------------
/// <summary>
/// The pair of Quantity_Color and Alpha component (1.0 opaque, 0.0 transparent).
/// </summary>
public ref class Quantity_ColorRGBA sealed : public BaseClass<::Quantity_ColorRGBA>
{

#ifdef Include_Quantity_ColorRGBA_h
public:
	Include_Quantity_ColorRGBA_h
#endif

public:
	Quantity_ColorRGBA(::Quantity_ColorRGBA* nativeInstance)
		: BaseClass<::Quantity_ColorRGBA>( nativeInstance, true )
	{}

	Quantity_ColorRGBA(::Quantity_ColorRGBA& nativeInstance)
		: BaseClass<::Quantity_ColorRGBA>( &nativeInstance, false )
	{}

	property ::Quantity_ColorRGBA* NativeInstance
	{
		::Quantity_ColorRGBA* get()
		{
			return static_cast<::Quantity_ColorRGBA*>(_NativeInstance);
		}
	}

public:
	/// <summary>
	/// Creates a color with the default value.
	/// </summary>
	Quantity_ColorRGBA();
	/// <summary>
	/// Creates the color with specified RGB value.
	/// </summary>
	Quantity_ColorRGBA(Macad::Occt::Quantity_Color^ theRgb);
	/// <summary>
	/// Creates the color with specified RGBA values.
	/// </summary>
	Quantity_ColorRGBA(Macad::Occt::Quantity_Color^ theRgb, float theAlpha);
	/// <summary>
	/// Creates the color from RGBA vector.
	/// </summary>
	/* Method skipped due to unknown mapping: void Quantity_ColorRGBA(NCollection_Vec4<float> theRgba, ) */
	/// <summary>
	/// Creates the color from RGBA values.
	/// </summary>
	Quantity_ColorRGBA(float theRed, float theGreen, float theBlue, float theAlpha);
	Quantity_ColorRGBA(Macad::Occt::Quantity_ColorRGBA^ parameter1);
	/// <summary>
	/// Assign new values to the color.
	/// </summary>
	void SetValues(float theRed, float theGreen, float theBlue, float theAlpha);
	/// <summary>
	/// Return RGB color value.
	/// </summary>
	Macad::Occt::Quantity_Color^ GetRGB();
	/// <summary>
	/// Modify RGB color components without affecting alpha value.
	/// </summary>
	Macad::Occt::Quantity_Color^ ChangeRGB();
	/// <summary>
	/// Assign RGB color components without affecting alpha value.
	/// </summary>
	void SetRGB(Macad::Occt::Quantity_Color^ theRgb);
	/// <summary>
	/// Return alpha value (1.0 means opaque, 0.0 means fully transparent).
	/// </summary>
	float Alpha();
	/// <summary>
	/// Assign the alpha value.
	/// </summary>
	void SetAlpha(float theAlpha);
	/// <summary>
	/// Returns true if the distance between colors is greater than Epsilon().
	/// </summary>
	bool IsDifferent(Macad::Occt::Quantity_ColorRGBA^ theOther);
	/// <summary>
	/// Two colors are considered to be equal if their distance is no greater than Epsilon().
	/// </summary>
	bool IsEqual(Macad::Occt::Quantity_ColorRGBA^ theOther);
	/// <summary>
	/// Finds color from predefined names.
	/// For example, the name of the color which corresponds to "BLACK" is Quantity_NOC_BLACK.
	/// An alpha component is set to 1.0.
	/// </summary>
	/// <param name="theColorNameString">
	/// the color name
	/// </param>
	/// <param name="theColor">
	/// a found color
	/// </param>
	/// <returns>
	/// false if the color name is unknown, or true if the search by color name was successful
	/// </returns>
	static bool ColorFromName(System::String^ theColorNameString, Macad::Occt::Quantity_ColorRGBA^ theColor);
	/// <summary>
	/// Parses the string as a hex color (like "#FF0" for short sRGB color, "#FF0F" for short sRGBA color,
	/// "#FFFF00" for RGB color, or "#FFFF00FF" for RGBA color)
	/// </summary>
	/// <param name="theHexColorString">
	/// the string to be parsed
	/// </param>
	/// <param name="theColor">
	/// a color that is a result of parsing
	/// </param>
	/// <param name="theAlphaComponentIsOff">
	/// the flag that indicates if a color alpha component is presented
	/// in the input string (false) or not (true)
	/// </param>
	/// <returns>
	/// true if parsing was successful, or false otherwise
	/// </returns>
	static bool ColorFromHex(char theHexColorString, Macad::Occt::Quantity_ColorRGBA^ theColor, bool theAlphaComponentIsOff);
	/// <summary>
	/// Parses the string as a hex color (like "#FF0" for short sRGB color, "#FF0F" for short sRGBA color,
	/// "#FFFF00" for RGB color, or "#FFFF00FF" for RGBA color)
	/// </summary>
	/// <param name="theHexColorString">
	/// the string to be parsed
	/// </param>
	/// <param name="theColor">
	/// a color that is a result of parsing
	/// </param>
	/// <param name="theAlphaComponentIsOff">
	/// the flag that indicates if a color alpha component is presented
	/// in the input string (false) or not (true)
	/// </param>
	/// <returns>
	/// true if parsing was successful, or false otherwise
	/// </returns>
	static bool ColorFromHex(char theHexColorString, Macad::Occt::Quantity_ColorRGBA^ theColor);
	/// <summary>
	/// Returns hex sRGBA string in format "#RRGGBBAA".
	/// </summary>
	static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_ColorRGBA^ theColor, bool theToPrefixHash);
	/// <summary>
	/// Returns hex sRGBA string in format "#RRGGBBAA".
	/// </summary>
	static Macad::Occt::TCollection_AsciiString^ ColorToHex(Macad::Occt::Quantity_ColorRGBA^ theColor);
	/// <summary>
	/// Convert linear RGB components into sRGB using OpenGL specs formula.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec4<float> Convert_LinearRGB_To_sRGB(NCollection_Vec4<float> theRGB, ) */
	/// <summary>
	/// Convert sRGB components into linear RGB using OpenGL specs formula.
	/// </summary>
	/* Method skipped due to unknown mapping: NCollection_Vec4<float> Convert_sRGB_To_LinearRGB(NCollection_Vec4<float> theRGB, ) */
	/// <summary>
	/// Dumps the content of me into the stream
	/// </summary>
	/* Method skipped due to unknown mapping: void DumpJson(ostream theOStream, Standard_Integer theDepth, ) */
	/// <summary>
	/// Dumps the content of me into the stream
	/// </summary>
	/* Method skipped due to unknown mapping: void DumpJson(ostream theOStream, Standard_Integer theDepth, ) */
	/// <summary>
	/// Inits the content of me from the stream
	/// </summary>
	/* Method skipped due to unknown mapping: Standard_Boolean InitFromJson(stringstream theSStream, Standard_Integer theStreamPos, ) */
}; // class Quantity_ColorRGBA

//---------------------------------------------------------------------
//  Class  Quantity_DateDefinitionError
//---------------------------------------------------------------------
public ref class Quantity_DateDefinitionError sealed : public Macad::Occt::Standard_DomainError
{

#ifdef Include_Quantity_DateDefinitionError_h
public:
	Include_Quantity_DateDefinitionError_h
#endif

public:
	Quantity_DateDefinitionError(::Quantity_DateDefinitionError* nativeInstance)
		: Macad::Occt::Standard_DomainError( nativeInstance )
	{}

	Quantity_DateDefinitionError(::Quantity_DateDefinitionError& nativeInstance)
		: Macad::Occt::Standard_DomainError( nativeInstance )
	{}

	property ::Quantity_DateDefinitionError* NativeInstance
	{
		::Quantity_DateDefinitionError* get()
		{
			return static_cast<::Quantity_DateDefinitionError*>(_NativeInstance);
		}
	}

	static Macad::Occt::Quantity_DateDefinitionError^ CreateDowncasted(::Quantity_DateDefinitionError* instance);

public:
	Quantity_DateDefinitionError();
	Quantity_DateDefinitionError(System::String^ theMessage);
	Quantity_DateDefinitionError(System::String^ theMessage, System::String^ theStackTrace);
	Quantity_DateDefinitionError(Macad::Occt::Quantity_DateDefinitionError^ parameter1);
	static void Raise(System::String^ theMessage);
	static void Raise();
	/* Method skipped due to unknown mapping: void Raise(stringstream theMessage, ) */
	static Macad::Occt::Quantity_DateDefinitionError^ NewInstance(System::String^ theMessage);
	static Macad::Occt::Quantity_DateDefinitionError^ NewInstance();
	static Macad::Occt::Quantity_DateDefinitionError^ NewInstance(System::String^ theMessage, System::String^ theStackTrace);
}; // class Quantity_DateDefinitionError

//---------------------------------------------------------------------
//  Class  Quantity_Period
//---------------------------------------------------------------------
/// <summary>
/// Manages date intervals. For example, a Period object
/// gives the interval between two dates.
/// A period is expressed in seconds and microseconds.
/// </summary>
public ref class Quantity_Period sealed : public BaseClass<::Quantity_Period>
{

#ifdef Include_Quantity_Period_h
public:
	Include_Quantity_Period_h
#endif

public:
	Quantity_Period(::Quantity_Period* nativeInstance)
		: BaseClass<::Quantity_Period>( nativeInstance, true )
	{}

	Quantity_Period(::Quantity_Period& nativeInstance)
		: BaseClass<::Quantity_Period>( &nativeInstance, false )
	{}

	property ::Quantity_Period* NativeInstance
	{
		::Quantity_Period* get()
		{
			return static_cast<::Quantity_Period*>(_NativeInstance);
		}
	}

public:
	/// <summary>
	/// Creates a Period
	/// With:      0 <= dd
	/// 0 <= hh
	/// 0 <= mn
	/// 0 <= ss
	/// 0 <= mis
	/// 0 <= mics
	/// </summary>
	Quantity_Period(int dd, int hh, int mn, int ss, int mis, int mics);
	/// <summary>
	/// Creates a Period
	/// With:      0 <= dd
	/// 0 <= hh
	/// 0 <= mn
	/// 0 <= ss
	/// 0 <= mis
	/// 0 <= mics
	/// </summary>
	Quantity_Period(int dd, int hh, int mn, int ss, int mis);
	/// <summary>
	/// Creates a Period
	/// With:      0 <= dd
	/// 0 <= hh
	/// 0 <= mn
	/// 0 <= ss
	/// 0 <= mis
	/// 0 <= mics
	/// </summary>
	Quantity_Period(int dd, int hh, int mn, int ss);
	/// <summary>
	/// Creates a Period with a number of seconds and microseconds.
	/// Exceptions
	/// Quantity_PeriodDefinitionError:
	/// -   if the number of seconds expressed either by:
	/// -   dd days, hh hours, mn minutes and ss seconds, or
	/// -   Ss
	/// is less than 0.
	/// -   if the number of microseconds expressed either by:
	/// -   mis milliseconds and mics microseconds, or
	/// -   Mics
	/// is less than 0.
	/// </summary>
	Quantity_Period(int ss, int mics);
	/// <summary>
	/// Creates a Period with a number of seconds and microseconds.
	/// Exceptions
	/// Quantity_PeriodDefinitionError:
	/// -   if the number of seconds expressed either by:
	/// -   dd days, hh hours, mn minutes and ss seconds, or
	/// -   Ss
	/// is less than 0.
	/// -   if the number of microseconds expressed either by:
	/// -   mis milliseconds and mics microseconds, or
	/// -   Mics
	/// is less than 0.
	/// </summary>
	Quantity_Period(int ss);
	Quantity_Period(Macad::Occt::Quantity_Period^ parameter1);
	/// <summary>
	/// Decomposes this period into a number of days,hours,
	/// minutes,seconds,milliseconds and microseconds
	/// Example of return values:
	/// 2 days, 15 hours, 0 minute , 0 second
	/// 0 millisecond and 0 microsecond
	/// </summary>
	void Values(int% dd, int% hh, int% mn, int% ss, int% mis, int% mics);
	/// <summary>
	/// Returns the number of seconds in Ss and the
	/// number of remainding microseconds in Mics of this period.
	/// Example of return values: 3600 seconds and 0 microseconds
	/// </summary>
	void Values(int% ss, int% mics);
	/// <summary>
	/// Assigns to this period the time interval defined
	/// -   with dd days, hh hours, mn minutes, ss
	/// seconds, mis (defaulted to 0) milliseconds and
	/// mics (defaulted to 0) microseconds; or
	/// </summary>
	void SetValues(int dd, int hh, int mn, int ss, int mis, int mics);
	/// <summary>
	/// Assigns to this period the time interval defined
	/// -   with dd days, hh hours, mn minutes, ss
	/// seconds, mis (defaulted to 0) milliseconds and
	/// mics (defaulted to 0) microseconds; or
	/// </summary>
	void SetValues(int dd, int hh, int mn, int ss, int mis);
	/// <summary>
	/// Assigns to this period the time interval defined
	/// -   with dd days, hh hours, mn minutes, ss
	/// seconds, mis (defaulted to 0) milliseconds and
	/// mics (defaulted to 0) microseconds; or
	/// </summary>
	void SetValues(int dd, int hh, int mn, int ss);
	/// <summary>
	/// Assigns to this period the time interval defined
	/// -   with Ss seconds and Mics (defaulted to 0) microseconds.
	/// Exceptions
	/// Quantity_PeriodDefinitionError:
	/// -   if the number of seconds expressed either by:
	/// -   dd days, hh hours, mn minutes and ss seconds, or
	/// -   Ss
	/// is less than 0.
	/// -   if the number of microseconds expressed either by:
	/// -   mis milliseconds and mics microseconds, or
	/// -   Mics
	/// is less than 0.
	/// </summary>
	void SetValues(int ss, int mics);
	/// <summary>
	/// Assigns to this period the time interval defined
	/// -   with Ss seconds and Mics (defaulted to 0) microseconds.
	/// Exceptions
	/// Quantity_PeriodDefinitionError:
	/// -   if the number of seconds expressed either by:
	/// -   dd days, hh hours, mn minutes and ss seconds, or
	/// -   Ss
	/// is less than 0.
	/// -   if the number of microseconds expressed either by:
	/// -   mis milliseconds and mics microseconds, or
	/// -   Mics
	/// is less than 0.
	/// </summary>
	void SetValues(int ss);
	/// <summary>
	/// Subtracts one Period from another and returns the difference.
	/// </summary>
	Macad::Occt::Quantity_Period^ Subtract(Macad::Occt::Quantity_Period^ anOther);
	/// <summary>
	/// Adds one Period to another one.
	/// </summary>
	Macad::Occt::Quantity_Period^ Add(Macad::Occt::Quantity_Period^ anOther);
	/// <summary>
	/// Returns TRUE if both <me> and <other> are equal.
	/// </summary>
	bool IsEqual(Macad::Occt::Quantity_Period^ anOther);
	/// <summary>
	/// Returns TRUE if <me> is shorter than <other>.
	/// </summary>
	bool IsShorter(Macad::Occt::Quantity_Period^ anOther);
	/// <summary>
	/// Returns TRUE if <me> is longer then <other>.
	/// </summary>
	bool IsLonger(Macad::Occt::Quantity_Period^ anOther);
	/// <summary>
	/// Checks the validity of a Period in form (dd,hh,mn,ss,mil,mic)
	/// With:      0 <= dd
	/// 0 <= hh
	/// 0 <= mn
	/// 0 <= ss
	/// 0 <= mis
	/// 0 <= mics
	/// </summary>
	static bool IsValid(int dd, int hh, int mn, int ss, int mis, int mics);
	/// <summary>
	/// Checks the validity of a Period in form (dd,hh,mn,ss,mil,mic)
	/// With:      0 <= dd
	/// 0 <= hh
	/// 0 <= mn
	/// 0 <= ss
	/// 0 <= mis
	/// 0 <= mics
	/// </summary>
	static bool IsValid(int dd, int hh, int mn, int ss, int mis);
	/// <summary>
	/// Checks the validity of a Period in form (dd,hh,mn,ss,mil,mic)
	/// With:      0 <= dd
	/// 0 <= hh
	/// 0 <= mn
	/// 0 <= ss
	/// 0 <= mis
	/// 0 <= mics
	/// </summary>
	static bool IsValid(int dd, int hh, int mn, int ss);
	/// <summary>
	/// Checks the validity of a Period in form (ss,mic)
	/// With:      0 <= ss
	/// 0 <= mics
	/// </summary>
	static bool IsValid(int ss, int mics);
	/// <summary>
	/// Checks the validity of a Period in form (ss,mic)
	/// With:      0 <= ss
	/// 0 <= mics
	/// </summary>
	static bool IsValid(int ss);
}; // class Quantity_Period

//---------------------------------------------------------------------
//  Class  Quantity_Date
//---------------------------------------------------------------------
/// <summary>
/// This class provides services to manage date information.
/// A date represents the following time intervals:
/// year, month, day, hour, minute, second,
/// millisecond and microsecond.
/// Current time is expressed in elapsed seconds
/// and microseconds beginning from 00:00 GMT,
/// January 1, 1979 (zero hour). The valid date can
/// only be later than this one.
/// Note: a Period object gives the interval between two dates.
/// </summary>
public ref class Quantity_Date sealed : public BaseClass<::Quantity_Date>
{

#ifdef Include_Quantity_Date_h
public:
	Include_Quantity_Date_h
#endif

public:
	Quantity_Date(::Quantity_Date* nativeInstance)
		: BaseClass<::Quantity_Date>( nativeInstance, true )
	{}

	Quantity_Date(::Quantity_Date& nativeInstance)
		: BaseClass<::Quantity_Date>( &nativeInstance, false )
	{}

	property ::Quantity_Date* NativeInstance
	{
		::Quantity_Date* get()
		{
			return static_cast<::Quantity_Date*>(_NativeInstance);
		}
	}

public:
	/// <summary>
	/// Constructs a default date
	/// (00:00 GMT, January 1, 1979 (zero hour)); use the function
	/// SetValues to define the required date; or
	/// </summary>
	Quantity_Date();
	/// <summary>
	/// Constructs a date from the year yyyy, the
	/// month mm, the day dd, the hour hh, the minute
	/// mn, the second ss, the millisecond mis
	/// (defaulted to 0) and the microsecond mics (defaulted to 0)..
	/// With:      1 <= mm <= 12
	/// 1 <= dd <= max number of days of <mm>
	/// 1979 <= yyyy
	/// 0 <= hh <= 23
	/// 0 <= mn <= 59
	/// 0 <= ss <= 59
	/// 0 <= mis <= 999
	/// 0 <= mics <= 999
	/// Exceptions
	/// Quantity_DateDefinitionError if mm, dd, hh,
	/// mn, ss, mis and mics are not the components of the valid date.
	/// </summary>
	Quantity_Date(int mm, int dd, int yyyy, int hh, int mn, int ss, int mis, int mics);
	/// <summary>
	/// Constructs a date from the year yyyy, the
	/// month mm, the day dd, the hour hh, the minute
	/// mn, the second ss, the millisecond mis
	/// (defaulted to 0) and the microsecond mics (defaulted to 0)..
	/// With:      1 <= mm <= 12
	/// 1 <= dd <= max number of days of <mm>
	/// 1979 <= yyyy
	/// 0 <= hh <= 23
	/// 0 <= mn <= 59
	/// 0 <= ss <= 59
	/// 0 <= mis <= 999
	/// 0 <= mics <= 999
	/// Exceptions
	/// Quantity_DateDefinitionError if mm, dd, hh,
	/// mn, ss, mis and mics are not the components of the valid date.
	/// </summary>
	Quantity_Date(int mm, int dd, int yyyy, int hh, int mn, int ss, int mis);
	/// <summary>
	/// Constructs a date from the year yyyy, the
	/// month mm, the day dd, the hour hh, the minute
	/// mn, the second ss, the millisecond mis
	/// (defaulted to 0) and the microsecond mics (defaulted to 0)..
	/// With:      1 <= mm <= 12
	/// 1 <= dd <= max number of days of <mm>
	/// 1979 <= yyyy
	/// 0 <= hh <= 23
	/// 0 <= mn <= 59
	/// 0 <= ss <= 59
	/// 0 <= mis <= 999
	/// 0 <= mics <= 999
	/// Exceptions
	/// Quantity_DateDefinitionError if mm, dd, hh,
	/// mn, ss, mis and mics are not the components of the valid date.
	/// </summary>
	Quantity_Date(int mm, int dd, int yyyy, int hh, int mn, int ss);
	Quantity_Date(Macad::Occt::Quantity_Date^ parameter1);
	/// <summary>
	/// Gets a complete Date.
	/// -   in mm - the month,
	/// -   in dd - the day,
	/// -   in yyyy - the year,
	/// -   in hh - the hour,
	/// -   in mn - the minute,
	/// -   in ss - the second,
	/// -   in mis - the millisecond, and
	/// -   in mics - the microsecond
	/// </summary>
	void Values(int% mm, int% dd, int% yy, int% hh, int% mn, int% ss, int% mis, int% mics);
	/// <summary>
	/// Assigns to this date the year yyyy, the month
	/// mm, the day dd, the hour hh, the minute mn, the
	/// second ss, the millisecond mis (defaulted to 0)
	/// and the microsecond mics (defaulted to 0).
	/// Exceptions
	/// Quantity_DateDefinitionError if mm, dd, hh,
	/// mn, ss, mis and mics are not components of a valid date.
	/// </summary>
	void SetValues(int mm, int dd, int yy, int hh, int mn, int ss, int mis, int mics);
	/// <summary>
	/// Assigns to this date the year yyyy, the month
	/// mm, the day dd, the hour hh, the minute mn, the
	/// second ss, the millisecond mis (defaulted to 0)
	/// and the microsecond mics (defaulted to 0).
	/// Exceptions
	/// Quantity_DateDefinitionError if mm, dd, hh,
	/// mn, ss, mis and mics are not components of a valid date.
	/// </summary>
	void SetValues(int mm, int dd, int yy, int hh, int mn, int ss, int mis);
	/// <summary>
	/// Assigns to this date the year yyyy, the month
	/// mm, the day dd, the hour hh, the minute mn, the
	/// second ss, the millisecond mis (defaulted to 0)
	/// and the microsecond mics (defaulted to 0).
	/// Exceptions
	/// Quantity_DateDefinitionError if mm, dd, hh,
	/// mn, ss, mis and mics are not components of a valid date.
	/// </summary>
	void SetValues(int mm, int dd, int yy, int hh, int mn, int ss);
	/// <summary>
	/// Subtracts one Date from another one to find the period
	/// between and returns the value.
	/// The result is the absolute value between the difference
	/// of two dates.
	/// </summary>
	Macad::Occt::Quantity_Period^ Difference(Macad::Occt::Quantity_Date^ anOther);
	/// <summary>
	/// Subtracts a period from a Date and returns the new Date.
	/// Raises an exception if the result date is anterior to
	/// Jan 1, 1979.
	/// </summary>
	Macad::Occt::Quantity_Date^ Subtract(Macad::Occt::Quantity_Period^ aPeriod);
	/// <summary>
	/// Adds a Period to a Date and returns the new Date.
	/// </summary>
	Macad::Occt::Quantity_Date^ Add(Macad::Occt::Quantity_Period^ aPeriod);
	/// <summary>
	/// Returns year of a Date.
	/// </summary>
	int Year();
	/// <summary>
	/// Returns month of a Date.
	/// </summary>
	int Month();
	/// <summary>
	/// Returns Day of a Date.
	/// </summary>
	int Day();
	/// <summary>
	/// Returns Hour of a Date.
	/// </summary>
	int Hour();
	/// <summary>
	/// Returns minute of a Date.
	/// </summary>
	int Minute();
	/// <summary>
	/// Returns seconde of a Date.
	/// </summary>
	int Second();
	/// <summary>
	/// Returns millisecond of a Date.
	/// </summary>
	int MilliSecond();
	/// <summary>
	/// Returns microsecond of a Date.
	/// </summary>
	int MicroSecond();
	/// <summary>
	/// Returns TRUE if both <me> and <other> are equal.
	/// This method is an alias of operator ==.
	/// </summary>
	bool IsEqual(Macad::Occt::Quantity_Date^ anOther);
	/// <summary>
	/// Returns TRUE if <me> is earlier than <other>.
	/// </summary>
	bool IsEarlier(Macad::Occt::Quantity_Date^ anOther);
	/// <summary>
	/// Returns TRUE if <me> is later then <other>.
	/// </summary>
	bool IsLater(Macad::Occt::Quantity_Date^ anOther);
	/// <summary>
	/// Checks the validity of a date - returns true if a
	/// date defined from the year yyyy, the month mm,
	/// the day dd, the hour hh, the minute mn, the
	/// second ss, the millisecond mis (defaulted to 0)
	/// and the microsecond mics (defaulted to 0) is valid.
	/// A date must satisfy the conditions above:
	/// -   yyyy is greater than or equal to 1979,
	/// -   mm lies within the range [1, 12] (with 1
	/// corresponding to January and 12 to December),
	/// -   dd lies within a valid range for the month mm
	/// (from 1 to 28, 29, 30 or 31 depending on
	/// mm and whether yyyy is a leap year or not),
	/// -   hh lies within the range [0, 23],
	/// -   mn lies within the range [0, 59],
	/// -   ss lies within the range [0, 59],
	/// -   mis lies within the range [0, 999],
	/// -   mics lies within the range [0, 999].C
	/// </summary>
	static bool IsValid(int mm, int dd, int yy, int hh, int mn, int ss, int mis, int mics);
	/// <summary>
	/// Checks the validity of a date - returns true if a
	/// date defined from the year yyyy, the month mm,
	/// the day dd, the hour hh, the minute mn, the
	/// second ss, the millisecond mis (defaulted to 0)
	/// and the microsecond mics (defaulted to 0) is valid.
	/// A date must satisfy the conditions above:
	/// -   yyyy is greater than or equal to 1979,
	/// -   mm lies within the range [1, 12] (with 1
	/// corresponding to January and 12 to December),
	/// -   dd lies within a valid range for the month mm
	/// (from 1 to 28, 29, 30 or 31 depending on
	/// mm and whether yyyy is a leap year or not),
	/// -   hh lies within the range [0, 23],
	/// -   mn lies within the range [0, 59],
	/// -   ss lies within the range [0, 59],
	/// -   mis lies within the range [0, 999],
	/// -   mics lies within the range [0, 999].C
	/// </summary>
	static bool IsValid(int mm, int dd, int yy, int hh, int mn, int ss, int mis);
	/// <summary>
	/// Checks the validity of a date - returns true if a
	/// date defined from the year yyyy, the month mm,
	/// the day dd, the hour hh, the minute mn, the
	/// second ss, the millisecond mis (defaulted to 0)
	/// and the microsecond mics (defaulted to 0) is valid.
	/// A date must satisfy the conditions above:
	/// -   yyyy is greater than or equal to 1979,
	/// -   mm lies within the range [1, 12] (with 1
	/// corresponding to January and 12 to December),
	/// -   dd lies within a valid range for the month mm
	/// (from 1 to 28, 29, 30 or 31 depending on
	/// mm and whether yyyy is a leap year or not),
	/// -   hh lies within the range [0, 23],
	/// -   mn lies within the range [0, 59],
	/// -   ss lies within the range [0, 59],
	/// -   mis lies within the range [0, 999],
	/// -   mics lies within the range [0, 999].C
	/// </summary>
	static bool IsValid(int mm, int dd, int yy, int hh, int mn, int ss);
	/// <summary>
	/// Returns true if a year is a leap year.
	/// The leap years are divisible by 4 and not by 100 except
	/// the years divisible by 400.
	/// </summary>
	static bool IsLeap(int yy);
}; // class Quantity_Date

//---------------------------------------------------------------------
//  Class  Quantity_HArray1OfColor
//---------------------------------------------------------------------
public ref class Quantity_HArray1OfColor sealed : public Macad::Occt::Standard_Transient
{

#ifdef Include_Quantity_HArray1OfColor_h
public:
	Include_Quantity_HArray1OfColor_h
#endif

public:
	Quantity_HArray1OfColor(::Quantity_HArray1OfColor* nativeInstance)
		: Macad::Occt::Standard_Transient( nativeInstance )
	{}

	Quantity_HArray1OfColor(::Quantity_HArray1OfColor& nativeInstance)
		: Macad::Occt::Standard_Transient( nativeInstance )
	{}

	property ::Quantity_HArray1OfColor* NativeInstance
	{
		::Quantity_HArray1OfColor* get()
		{
			return static_cast<::Quantity_HArray1OfColor*>(_NativeInstance);
		}
	}

	static Macad::Occt::Quantity_HArray1OfColor^ CreateDowncasted(::Quantity_HArray1OfColor* instance);

public:
	Quantity_HArray1OfColor();
	Quantity_HArray1OfColor(int theLower, int theUpper);
	Quantity_HArray1OfColor(int theLower, int theUpper, Macad::Occt::Quantity_Color^ theValue);
	Quantity_HArray1OfColor(Macad::Occt::Quantity_Array1OfColor^ theOther);
	Quantity_HArray1OfColor(Macad::Occt::Quantity_HArray1OfColor^ parameter1);
	Macad::Occt::Quantity_Array1OfColor^ Array1();
	Macad::Occt::Quantity_Array1OfColor^ ChangeArray1();
	void Init(Macad::Occt::Quantity_Color^ theValue);
	int Size();
	int Length();
	bool IsEmpty();
	int Lower();
	int Upper();
	bool IsDeletable();
	bool IsAllocated();
	/* Method skipped due to unknown mapping: NCollection_Array1<Quantity_Color> Assign(NCollection_Array1<Quantity_Color> theOther, ) */
	/* Method skipped due to unknown mapping: NCollection_Array1<Quantity_Color> Move(NCollection_Array1<Quantity_Color> theOther, ) */
	Macad::Occt::Quantity_Color^ First();
	Macad::Occt::Quantity_Color^ ChangeFirst();
	Macad::Occt::Quantity_Color^ Last();
	Macad::Occt::Quantity_Color^ ChangeLast();
	Macad::Occt::Quantity_Color^ Value(int theIndex);
	Macad::Occt::Quantity_Color^ ChangeValue(int theIndex);
	void SetValue(int theIndex, Macad::Occt::Quantity_Color^ theItem);
	void Resize(int theLower, int theUpper, bool theToCopyData);
}; // class Quantity_HArray1OfColor

//---------------------------------------------------------------------
//  Class  Quantity_PeriodDefinitionError
//---------------------------------------------------------------------
public ref class Quantity_PeriodDefinitionError sealed : public Macad::Occt::Standard_DomainError
{

#ifdef Include_Quantity_PeriodDefinitionError_h
public:
	Include_Quantity_PeriodDefinitionError_h
#endif

public:
	Quantity_PeriodDefinitionError(::Quantity_PeriodDefinitionError* nativeInstance)
		: Macad::Occt::Standard_DomainError( nativeInstance )
	{}

	Quantity_PeriodDefinitionError(::Quantity_PeriodDefinitionError& nativeInstance)
		: Macad::Occt::Standard_DomainError( nativeInstance )
	{}

	property ::Quantity_PeriodDefinitionError* NativeInstance
	{
		::Quantity_PeriodDefinitionError* get()
		{
			return static_cast<::Quantity_PeriodDefinitionError*>(_NativeInstance);
		}
	}

	static Macad::Occt::Quantity_PeriodDefinitionError^ CreateDowncasted(::Quantity_PeriodDefinitionError* instance);

public:
	Quantity_PeriodDefinitionError();
	Quantity_PeriodDefinitionError(System::String^ theMessage);
	Quantity_PeriodDefinitionError(System::String^ theMessage, System::String^ theStackTrace);
	Quantity_PeriodDefinitionError(Macad::Occt::Quantity_PeriodDefinitionError^ parameter1);
	static void Raise(System::String^ theMessage);
	static void Raise();
	/* Method skipped due to unknown mapping: void Raise(stringstream theMessage, ) */
	static Macad::Occt::Quantity_PeriodDefinitionError^ NewInstance(System::String^ theMessage);
	static Macad::Occt::Quantity_PeriodDefinitionError^ NewInstance();
	static Macad::Occt::Quantity_PeriodDefinitionError^ NewInstance(System::String^ theMessage, System::String^ theStackTrace);
}; // class Quantity_PeriodDefinitionError

}; // namespace Occt
}; // namespace Macad
